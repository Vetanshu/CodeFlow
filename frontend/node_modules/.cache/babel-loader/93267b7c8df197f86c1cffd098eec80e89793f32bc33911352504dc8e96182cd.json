{"ast":null,"code":"import { NodeProp } from '@lezer/common';\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n  /// @internal\n  constructor(\n  /// The set of this tag and all its parent tags, starting with\n  /// this one itself and sorted in order of decreasing specificity.\n  set,\n  /// The base unmodified tag that this one is based on, if it's\n  /// modified @internal\n  base,\n  /// The modifiers applied to this.base @internal\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /// @internal\n    this.id = nextTagID++;\n  }\n  /// Define a new tag. If `parent` is given, the tag is treated as a\n  /// sub-tag of that parent, and\n  /// [highlighters](#highlight.tagHighlighter) that don't mention\n  /// this tag will try to fall back to the parent tag (or grandparent\n  /// tag, etc).\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  /// Define a tag _modifier_, which is a function that, given a tag,\n  /// will return a tag that is a subtag of the original. Applying the\n  /// same modifier to a twice tag will return the same value (`m1(t1)\n  /// == m1(t1)`) and applying multiple modifiers will, regardless or\n  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  ///\n  /// When multiple modifiers are applied to a given base tag, each\n  /// smaller set of modifiers is registered as a parent, so that for\n  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  /// `m1(m3(t1)`, and so on.\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n}\nlet nextModifierID = 0;\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n      tag = new Tag(set, base, mods);\n    for (let m of mods) m.instances.push(tag);\n    let configs = powerSet(mods);\n    for (let parent of base.set) if (!parent.modified.length) for (let config of configs) set.push(Modifier.get(parent, config));\n    return tag;\n  }\n}\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n  let sets = [[]];\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0, e = sets.length; j < e; j++) {\n      sets.push(sets[j].concat(array[i]));\n    }\n  }\n  return sets.sort((a, b) => b.length - a.length);\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelâ€”wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n        mode = 2 /* Mode.Normal */,\n        rest = part;\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1 /* Mode.Inherit */;\n          break;\n        }\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n        if (pos == part.length && next == \"!\") {\n          mode = 0 /* Mode.Opaque */;\n          break;\n        }\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n      let last = pieces.length - 1,\n        inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n  return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n  get opaque() {\n    return this.mode == 0 /* Mode.Opaque */;\n  }\n  get inherit() {\n    return this.mode == 1 /* Mode.Inherit */;\n  }\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n    other.next = this.sort(other.next);\n    return other;\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n  let map = Object.create(null);\n  for (let style of tags) {\n    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else for (let tag of style.tag) map[tag.id] = style.class;\n  }\n  let {\n    scope,\n    all = null\n  } = options || {};\n  return {\n    style: tags => {\n      let cls = all;\n      for (let tag of tags) {\n        for (let sub of tag.set) {\n          let tagClass = map[sub.id];\n          if (tagClass) {\n            cls = cls ? cls + \" \" + tagClass : tagClass;\n            break;\n          }\n        }\n      }\n      return cls;\n    },\n    scope\n  };\n}\nfunction highlightTags(highlighters, tags) {\n  let result = null;\n  for (let highlighter of highlighters) {\n    let value = highlighter.style(tags);\n    if (value) result = result ? result + \" \" + value : value;\n  }\n  return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter,\n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle) {\n  let from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : tree.length;\n  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\nclass HighlightBuilder {\n  constructor(at, highlighters, span) {\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n  highlightRange(cursor, from, to, inheritedClass, highlighters) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n    let cls = inheritedClass;\n    let rule = getStyleTags(cursor) || Rule.empty;\n    let tagCls = highlightTags(highlighters, rule.tags);\n    if (tagCls) {\n      if (cls) cls += \" \";\n      cls += tagCls;\n      if (rule.mode == 1 /* Mode.Inherit */) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n    }\n    this.startSpan(cursor.from, cls);\n    if (rule.opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n      let hasChild = cursor.firstChild();\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n          rangeTo = Math.min(to, nextPos);\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n            this.startSpan(Math.min(rangeTo, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n        if (pos > from) {\n          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n          this.startSpan(pos, cls);\n        }\n      }\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n      cursor.parent();\n    }\n  }\n}\n/// Match a syntax node's [highlight rules](#highlight.styleTags). If\n/// there's a match, return its set of tags, and whether it is\n/// opaque (uses a `!`) or applies to all child nodes (`/...`).\nfunction getStyleTags(node) {\n  let rule = node.type.prop(ruleNodeProp);\n  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;\n  return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(),\n  name = t(),\n  typeName = t(name),\n  propertyName = t(name),\n  literal = t(),\n  string = t(literal),\n  number = t(literal),\n  content = t(),\n  heading = t(content),\n  keyword = t(),\n  operator = t(),\n  punctuation = t(),\n  bracket = t(punctuation),\n  meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementâ€”if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n  /// A comment.\n  comment,\n  /// A line [comment](#highlight.tags.comment).\n  lineComment: t(comment),\n  /// A block [comment](#highlight.tags.comment).\n  blockComment: t(comment),\n  /// A documentation [comment](#highlight.tags.comment).\n  docComment: t(comment),\n  /// Any kind of identifier.\n  name,\n  /// The [name](#highlight.tags.name) of a variable.\n  variableName: t(name),\n  /// A type [name](#highlight.tags.name).\n  typeName: typeName,\n  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  tagName: t(typeName),\n  /// A property or field [name](#highlight.tags.name).\n  propertyName: propertyName,\n  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  attributeName: t(propertyName),\n  /// The [name](#highlight.tags.name) of a class.\n  className: t(name),\n  /// A label [name](#highlight.tags.name).\n  labelName: t(name),\n  /// A namespace [name](#highlight.tags.name).\n  namespace: t(name),\n  /// The [name](#highlight.tags.name) of a macro.\n  macroName: t(name),\n  /// A literal value.\n  literal,\n  /// A string [literal](#highlight.tags.literal).\n  string,\n  /// A documentation [string](#highlight.tags.string).\n  docString: t(string),\n  /// A character literal (subtag of [string](#highlight.tags.string)).\n  character: t(string),\n  /// An attribute value (subtag of [string](#highlight.tags.string)).\n  attributeValue: t(string),\n  /// A number [literal](#highlight.tags.literal).\n  number,\n  /// An integer [number](#highlight.tags.number) literal.\n  integer: t(number),\n  /// A floating-point [number](#highlight.tags.number) literal.\n  float: t(number),\n  /// A boolean [literal](#highlight.tags.literal).\n  bool: t(literal),\n  /// Regular expression [literal](#highlight.tags.literal).\n  regexp: t(literal),\n  /// An escape [literal](#highlight.tags.literal), for example a\n  /// backslash escape in a string.\n  escape: t(literal),\n  /// A color [literal](#highlight.tags.literal).\n  color: t(literal),\n  /// A URL [literal](#highlight.tags.literal).\n  url: t(literal),\n  /// A language keyword.\n  keyword,\n  /// The [keyword](#highlight.tags.keyword) for the self or this\n  /// object.\n  self: t(keyword),\n  /// The [keyword](#highlight.tags.keyword) for null.\n  null: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  atom: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that represents a unit.\n  unit: t(keyword),\n  /// A modifier [keyword](#highlight.tags.keyword).\n  modifier: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n  operatorKeyword: t(keyword),\n  /// A control-flow related [keyword](#highlight.tags.keyword).\n  controlKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that defines something.\n  definitionKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) related to defining or\n  /// interfacing with modules.\n  moduleKeyword: t(keyword),\n  /// An operator.\n  operator,\n  /// An [operator](#highlight.tags.operator) that dereferences something.\n  derefOperator: t(operator),\n  /// Arithmetic-related [operator](#highlight.tags.operator).\n  arithmeticOperator: t(operator),\n  /// Logical [operator](#highlight.tags.operator).\n  logicOperator: t(operator),\n  /// Bit [operator](#highlight.tags.operator).\n  bitwiseOperator: t(operator),\n  /// Comparison [operator](#highlight.tags.operator).\n  compareOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that updates its operand.\n  updateOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that defines something.\n  definitionOperator: t(operator),\n  /// Type-related [operator](#highlight.tags.operator).\n  typeOperator: t(operator),\n  /// Control-flow [operator](#highlight.tags.operator).\n  controlOperator: t(operator),\n  /// Program or markup punctuation.\n  punctuation,\n  /// [Punctuation](#highlight.tags.punctuation) that separates\n  /// things.\n  separator: t(punctuation),\n  /// Bracket-style [punctuation](#highlight.tags.punctuation).\n  bracket,\n  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  /// tokens).\n  angleBracket: t(bracket),\n  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  /// tokens).\n  squareBracket: t(bracket),\n  /// Parentheses (usually `(` and `)` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  paren: t(bracket),\n  /// Braces (usually `{` and `}` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  brace: t(bracket),\n  /// Content, for example plain text in XML or markup documents.\n  content,\n  /// [Content](#highlight.tags.content) that represents a heading.\n  heading,\n  /// A level 1 [heading](#highlight.tags.heading).\n  heading1: t(heading),\n  /// A level 2 [heading](#highlight.tags.heading).\n  heading2: t(heading),\n  /// A level 3 [heading](#highlight.tags.heading).\n  heading3: t(heading),\n  /// A level 4 [heading](#highlight.tags.heading).\n  heading4: t(heading),\n  /// A level 5 [heading](#highlight.tags.heading).\n  heading5: t(heading),\n  /// A level 6 [heading](#highlight.tags.heading).\n  heading6: t(heading),\n  /// A prose separator (such as a horizontal rule).\n  contentSeparator: t(content),\n  /// [Content](#highlight.tags.content) that represents a list.\n  list: t(content),\n  /// [Content](#highlight.tags.content) that represents a quote.\n  quote: t(content),\n  /// [Content](#highlight.tags.content) that is emphasized.\n  emphasis: t(content),\n  /// [Content](#highlight.tags.content) that is styled strong.\n  strong: t(content),\n  /// [Content](#highlight.tags.content) that is part of a link.\n  link: t(content),\n  /// [Content](#highlight.tags.content) that is styled as code or\n  /// monospace.\n  monospace: t(content),\n  /// [Content](#highlight.tags.content) that has a strike-through\n  /// style.\n  strikethrough: t(content),\n  /// Inserted text in a change-tracking format.\n  inserted: t(),\n  /// Deleted text.\n  deleted: t(),\n  /// Changed text.\n  changed: t(),\n  /// An invalid or unsyntactic element.\n  invalid: t(),\n  /// Metadata or meta-instruction.\n  meta,\n  /// [Metadata](#highlight.tags.meta) that applies to the entire\n  /// document.\n  documentMeta: t(meta),\n  /// [Metadata](#highlight.tags.meta) that annotates or adds\n  /// attributes to a given syntactic element.\n  annotation: t(meta),\n  /// Processing instruction or preprocessor directive. Subtag of\n  /// [meta](#highlight.tags.meta).\n  processingInstruction: t(meta),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  /// given element is being defined. Expected to be used with the\n  /// various [name](#highlight.tags.name) tags.\n  definition: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n  /// something is constant. Mostly expected to be used with\n  /// [variable names](#highlight.tags.variableName).\n  constant: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  /// a [variable](#highlight.tags.variableName) or [property\n  /// name](#highlight.tags.propertyName) is being called or defined\n  /// as a function.\n  function: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  /// [names](#highlight.tags.name) to indicate that they belong to\n  /// the language's standard environment.\n  standard: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  /// [names](#highlight.tags.name) is local to some scope.\n  local: Tag.defineModifier(),\n  /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n  /// can be used to tag language-specific alternative variants of\n  /// some common tag. It is recommended for themes to define special\n  /// forms of at least the [string](#highlight.tags.string) and\n  /// [variable name](#highlight.tags.variableName) tags, since those\n  /// come up a lot.\n  special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\nexport { Tag, classHighlighter, getStyleTags, highlightTree, styleTags, tagHighlighter, tags };","map":{"version":3,"names":["NodeProp","nextTagID","Tag","constructor","set","base","modified","id","define","parent","Error","tag","push","t","defineModifier","mod","Modifier","indexOf","get","concat","sort","a","b","nextModifierID","instances","mods","length","exists","find","sameArray","m","configs","powerSet","config","every","x","i","array","sets","j","e","styleTags","spec","byName","Object","create","prop","tags","Array","isArray","part","split","pieces","mode","rest","pos","exec","RangeError","JSON","parse","next","slice","last","inner","rule","Rule","ruleNodeProp","add","context","opaque","inherit","other","depth","empty","tagHighlighter","options","map","style","class","scope","all","cls","sub","tagClass","highlightTags","highlighters","result","highlighter","value","highlightTree","tree","putStyle","from","to","builder","HighlightBuilder","highlightRange","cursor","flush","at","span","startSpan","inheritedClass","type","start","end","isTop","filter","h","getStyleTags","tagCls","mounted","overlay","node","enter","innerHighlighters","hasChild","firstChild","nextPos","rangeFrom","Math","max","rangeTo","min","nextSibling","matchContext","comment","name","typeName","propertyName","literal","string","number","content","heading","keyword","operator","punctuation","bracket","meta","lineComment","blockComment","docComment","variableName","tagName","attributeName","className","labelName","namespace","macroName","docString","character","attributeValue","integer","float","bool","regexp","escape","color","url","self","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","moduleKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","separator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","contentSeparator","list","quote","emphasis","strong","link","monospace","strikethrough","inserted","deleted","changed","invalid","documentMeta","annotation","processingInstruction","definition","constant","function","standard","local","special","classHighlighter"],"sources":["/Users/kunal/Desktop/Vetanshu/CodeCollab/frontend/node_modules/@lezer/highlight/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlighter](#highlight.Highlighter).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of this tag and all its parent tags, starting with\n    /// this one itself and sorted in order of decreasing specificity.\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and\n    /// [highlighters](#highlight.tagHighlighter) that don't mention\n    /// this tag will try to fall back to the parent tag (or grandparent\n    /// tag, etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = powerSet(mods);\n        for (let parent of base.set)\n            if (!parent.modified.length)\n                for (let config of configs)\n                    set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n    let sets = [[]];\n    for (let i = 0; i < array.length; i++) {\n        for (let j = 0, e = sets.length; j < e; j++) {\n            sets.push(sets[j].concat(array[i]));\n        }\n    }\n    return sets.sort((a, b) => b.length - a.length);\n}\n/// This function is used to add a set of tags to a language syntax\n/// via [`NodeSet.extend`](#common.NodeSet.extend) or\n/// [`LRParser.configure`](#lr.LRParser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node name](#common.NodeType.name), or\n/// multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelâ€”wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Mode.Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Mode.Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    get opaque() { return this.mode == 0 /* Mode.Opaque */; }\n    get inherit() { return this.mode == 1 /* Mode.Inherit */; }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/// Define a [highlighter](#highlight.Highlighter) from an array of\n/// tag/class pairs. Classes associated with more specific tags will\n/// take precedence.\nfunction tagHighlighter(tags, options) {\n    let map = Object.create(null);\n    for (let style of tags) {\n        if (!Array.isArray(style.tag))\n            map[style.tag.id] = style.class;\n        else\n            for (let tag of style.tag)\n                map[tag.id] = style.class;\n    }\n    let { scope, all = null } = options || {};\n    return {\n        style: (tags) => {\n            let cls = all;\n            for (let tag of tags) {\n                for (let sub of tag.set) {\n                    let tagClass = map[sub.id];\n                    if (tagClass) {\n                        cls = cls ? cls + \" \" + tagClass : tagClass;\n                        break;\n                    }\n                }\n            }\n            return cls;\n        },\n        scope\n    };\n}\nfunction highlightTags(highlighters, tags) {\n    let result = null;\n    for (let highlighter of highlighters) {\n        let value = highlighter.style(tags);\n        if (value)\n            result = result ? result + \" \" + value : value;\n    }\n    return result;\n}\n/// Highlight the given [tree](#common.Tree) with the given\n/// [highlighter](#highlight.Highlighter).\nfunction highlightTree(tree, highlighter, \n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle, \n/// The start of the range to highlight.\nfrom = 0, \n/// The end of the range.\nto = tree.length) {\n    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n    builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n    builder.flush(to);\n}\nclass HighlightBuilder {\n    constructor(at, highlighters, span) {\n        this.at = at;\n        this.highlighters = highlighters;\n        this.span = span;\n        this.class = \"\";\n    }\n    startSpan(at, cls) {\n        if (cls != this.class) {\n            this.flush(at);\n            if (at > this.at)\n                this.at = at;\n            this.class = cls;\n        }\n    }\n    flush(to) {\n        if (to > this.at && this.class)\n            this.span(this.at, to, this.class);\n    }\n    highlightRange(cursor, from, to, inheritedClass, highlighters) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        if (type.isTop)\n            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n        let cls = inheritedClass;\n        let rule = getStyleTags(cursor) || Rule.empty;\n        let tagCls = highlightTags(highlighters, rule.tags);\n        if (tagCls) {\n            if (cls)\n                cls += \" \";\n            cls += tagCls;\n            if (rule.mode == 1 /* Mode.Inherit */)\n                inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n        }\n        this.startSpan(cursor.from, cls);\n        if (rule.opaque)\n            return;\n        let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);\n        if (mounted && mounted.overlay) {\n            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n            let hasChild = cursor.firstChild();\n            for (let i = 0, pos = start;; i++) {\n                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n                let nextPos = next ? next.from + start : end;\n                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);\n                if (rangeFrom < rangeTo && hasChild) {\n                    while (cursor.from < rangeTo) {\n                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n                        this.startSpan(Math.min(rangeTo, cursor.to), cls);\n                        if (cursor.to >= nextPos || !cursor.nextSibling())\n                            break;\n                    }\n                }\n                if (!next || nextPos > to)\n                    break;\n                pos = next.to + start;\n                if (pos > from) {\n                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), inheritedClass, innerHighlighters);\n                    this.startSpan(pos, cls);\n                }\n            }\n            if (hasChild)\n                cursor.parent();\n        }\n        else if (cursor.firstChild()) {\n            do {\n                if (cursor.to <= from)\n                    continue;\n                if (cursor.from >= to)\n                    break;\n                this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n                this.startSpan(Math.min(to, cursor.to), cls);\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n}\n/// Match a syntax node's [highlight rules](#highlight.styleTags). If\n/// there's a match, return its set of tags, and whether it is\n/// opaque (uses a `!`) or applies to all child nodes (`/...`).\nfunction getStyleTags(node) {\n    let rule = node.type.prop(ruleNodeProp);\n    while (rule && rule.context && !node.matchContext(rule.context))\n        rule = rule.next;\n    return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), propertyName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag).\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementâ€”if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type [name](#highlight.tags.name).\n    typeName: typeName,\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    tagName: t(typeName),\n    /// A property or field [name](#highlight.tags.name).\n    propertyName: propertyName,\n    /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n    attributeName: t(propertyName),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// An attribute value (subtag of [string](#highlight.tags.string)).\n    attributeValue: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) related to defining or\n    /// interfacing with modules.\n    moduleKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that dereferences something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// [Content](#highlight.tags.content) that has a strike-through\n    /// style.\n    strikethrough: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// This is a highlighter that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// The following tags are mapped to their name prefixed with `\"tok-\"`\n/// (for example `\"tok-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom)\n/// * [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`className`](#highlight.tags.className)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.punctuation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"tok-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"tok-variableName tok-definition\"`\n/// * [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n///   to `\"tok-propertyName tok-definition\"`\nconst classHighlighter = tagHighlighter([\n    { tag: tags.link, class: \"tok-link\" },\n    { tag: tags.heading, class: \"tok-heading\" },\n    { tag: tags.emphasis, class: \"tok-emphasis\" },\n    { tag: tags.strong, class: \"tok-strong\" },\n    { tag: tags.keyword, class: \"tok-keyword\" },\n    { tag: tags.atom, class: \"tok-atom\" },\n    { tag: tags.bool, class: \"tok-bool\" },\n    { tag: tags.url, class: \"tok-url\" },\n    { tag: tags.labelName, class: \"tok-labelName\" },\n    { tag: tags.inserted, class: \"tok-inserted\" },\n    { tag: tags.deleted, class: \"tok-deleted\" },\n    { tag: tags.literal, class: \"tok-literal\" },\n    { tag: tags.string, class: \"tok-string\" },\n    { tag: tags.number, class: \"tok-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"tok-string2\" },\n    { tag: tags.variableName, class: \"tok-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"tok-variableName tok-local\" },\n    { tag: tags.definition(tags.variableName), class: \"tok-variableName tok-definition\" },\n    { tag: tags.special(tags.variableName), class: \"tok-variableName2\" },\n    { tag: tags.definition(tags.propertyName), class: \"tok-propertyName tok-definition\" },\n    { tag: tags.typeName, class: \"tok-typeName\" },\n    { tag: tags.namespace, class: \"tok-namespace\" },\n    { tag: tags.className, class: \"tok-className\" },\n    { tag: tags.macroName, class: \"tok-macroName\" },\n    { tag: tags.propertyName, class: \"tok-propertyName\" },\n    { tag: tags.operator, class: \"tok-operator\" },\n    { tag: tags.comment, class: \"tok-comment\" },\n    { tag: tags.meta, class: \"tok-meta\" },\n    { tag: tags.invalid, class: \"tok-invalid\" },\n    { tag: tags.punctuation, class: \"tok-punctuation\" }\n]);\n\nexport { Tag, classHighlighter, getStyleTags, highlightTree, styleTags, tagHighlighter, tags };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}